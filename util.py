# -*- coding: utf-8 -*-
"""util

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1OyS540f7uEaXbYgTqFr9qOebethnkndc
"""

import torch
from torch.utils.data import Dataset
import os
import math

def extract_target(prediction,targets,n_grid,anchors,thresh,stride):
  xt,yt,wt,ht,conf,mask=torch.zeros(prediction.shape[:,:,:,:,0],dtype=torch.float64)
  conf_mask=torch.zeros(prediction.shape[:,:,:,:,0],dtype=torch.float64)
  classes=torch.zeros(prediction.shape[:,:,:,:,5:],dtype=torch.float64)
  for b in range(target.size[0]):
    for i in range(target.size[1]):
      target_x=grid*target[b,i,1]
      target_y=grid*target[b,i,2]
      x_grid=int(target_x)
      y_grid=int(target_y)
      anchors=[(0,0,int(i[0])/stride,int(i[1])/stride) for i in anchors ]
      anchors_t=np.array(anchors).reshape([len(anchors),4])
      iou=iou(target[b,i,1:]*grid,anchors_t)
      j=torch.argmax(iou) 
      mask[b,j,x_grid,y_grid,0]=1
      xt[b,j,y_grid,x_grid]=target_x-x_grid
      yt[b,j,y_grid,x_grid]=taget_y-y_grid
      wt[b,j,y_grid,x_grid]=math.log(target[b,i,3]*grid/anchors[j][0])
      ht[b,j,y_grid,x_grid]=math.log(target[b,i,4]*grid/anchors[j][1])
      classes[b,j,y_grid,x_grid,target[b,i,0]]=1
      conf[b,j,y_grid,x_grid]=1
      conf_mask[b,:,y_grid,x_grid]=0
      conf_mask[b,j,y_grid,x_grid]=1
  return xt,mask,yt,wt,ht,classes,conf,conf_mask

class loadingdata(Dataset):
  def __init__(self,image_path,target_path,inp_dim):
    ad_img=os.join.path(image_path)
    ad_target=os.join.path(target_path)
    self.images_path=[os.path.join(image_path,i) for i in os.listdir(ad_img)]
    self.target_path=[os.path.join(target_path,i) for i in os.listdir(target_path)]
    self.inp_dim=inp_dim
  def __getitem__(self,index):
    image=cv2.imread(self.image_path[index])
    w,h=image.size[0],image.size[1]
    pad_1,pad_2=np.abs(h-w)//2,np.abs(h-w)-np.abs(h-w)//2
    if h>w:
      pad=((pad_1,pad_2),(0,0),(0,0))
    else:
      pad=((0,0),(pad_1,pad_2),(0,0))
    final_image=np.pad(pad,constant,constantvalues=128)/255
    h_new,w_new=final_image.size[1],final_image.size[0]
    final_image=resize(final_iamge,(self.inp_dim[0],self.inp_dim[1],3),mode="reflect")
    final_image=np.transpose(final_image,(2,0,1))
    final_image=torch.from_numpy(final_image).float()
    target=self.target_path[index]
    target=np.loadtxt(target).reshape(-1,5)
    target[:,1]=(target[:,1]+pad[0][0])/w_new
    target[:,2]=(target[:,2]+pad[0][1])/h_new
    target[:,3]=(target[:,1])/w_new
    target[:,4]=(target[:,4]+pad[0][0])/h_new
    final_target=np.array(target)
    return final_image,final_target
  def __len__(self):
    return len(self.image_path)

def non_max_supression(prediction,confidence,num_class,nms_confidence):
  conf_mask=(prediction[:,:,4]>confidence).float().unsqueeze()
  prediction=prediction*conf_mask
  box_corner=prediction.new(prediction.shape)
  box_corner[:,:,0]=prediction[:,:,0]-prediction[:,:,2]/2
  box_corner[:,:,1]=prediction[:,:,1]-prediction[:,:,3]/2
  box_corner[:,:,2]=prediction[:,:,0]+prediction[:,:,2]/2
  box_corner[:,:,3]=prediction[:,:,1]+prediction[:,:,3]/2
  box_corner[:,:,4]=(prediction[:,:,4])
  batch_size=prediction.size(0)
  write=False
  for ind in range(batch_size):
    image=prediction[ind]
    max_conf,max_conf_score=torch.max(image[:,5:5+num_class],1)
    max_conf=max_conf.float().unsqueeze(1)
    max_conf_score=max_conf.score.float().unsqueeze(1)
    seq=(image[:,:5],max_conf,max_conf_score)
    image_pred=torch.cat(seq,1)
    non_zero_ind=torch.nonzero(image_pred[:4])
    try:
     image_pred_=image_pred[non_zero_ind.squeeze(),:].view(-1,7)
    except:
      continue
    img_classes=unique(image_pred_[:,-1])
    for cls in img_classes:
      class_mask=image_pred_*(image_pred_[:-1]==cls).unsqueeze(1)
      class_ind=torch.nonzero(image_pred_[:-2])
      image_pred_class=class_mask[class_ind.squeeze(),:].view(-1,7)
      conf_sort=torch.sort(image_pred_class[:4],descending=True)
      image_pred_class=image_pred_class[conf_sort]
      detections=image_pred_class.size(0)
    for i in range(detections):
      try:
        ious=bbox_iou(image_pred_class[i],image_pred_class[i+1:])
      except ValueError:
        break
      except IndexError:
        break
      iou_mask=(ious<nms_conf).float().unsqueeze(1)
      image_pred_class*=iou_mask
      ind=torch.nonzero(image_pred_class[:,4]).squeeze()
      image_pred_class=image_pred_class[ind,:].view(-1,7)
  return image_pred_class

def bbox_iou(box1,box2):
  box1_x1,box2_y1,box2_x1,box2_y1=box1[:,0],box1[:1],box2[:0],box2[:1]
  box1_x2,box2_y2,box2_x2,box2_y2=box1[:,2],box1[:3],box2[:2],box2[:3]
  inter_x1=max(box1_x1,box2_x1)
  inter_x2=min(box1_x2,box2_x2)
  inter_y1=max(box1_y1,box2_y1)
  inter_y2=min(box1_y2,box2_y2)
  a1=torch.clamp(box1_x2-box1_x1+1)*(box1_y2-box1_y1+1)
  a2=(box2_x2-box2_x1+1)*(box2_y2-box2_y1+1)
  inter_area=torch.clamp(inter_x2-inter_x1+1,min=0)*torch.clamp(inter_y2-inter_y1+1,min=0)
  union=a1+a2-inter_area
  return inter_area/union

def predict_transform(prediction,anchors,inp_dim,num_classes,CUDA=True):
  print(prediction.size(2))
  batch_size=prediction.size(0)
  stride=int(inp_dim)//prediction.size(2)
  grid_size=int(inp_dim)//stride
  print(grid_size)
  bbox_attrs=5+num_classes
  num_anchors=len(anchors)
  prediction=prediction.view(batch_size,grid_size*grid_size*num_anchors,bbox_attrs)
  print(prediction.size())
  anchors=[(a[0]/stride,a[1]/stride) for a in anchors]
  prediction[:,:,0]=torch.sigmoid(prediction[:,:,0])
  prediction[:,:,1]=torch.sigmoid(prediction[:,:,1])
  prediction[:,:,4]=torch.sigmoid(prediction[:,:,4])
  grid=np.arange(grid_size)
  a,b=np.meshgrid(grid,grid)
  x_offset=torch.FloatTensor(a).view(-1,1)
  y_offset=torch.FloatTensor(b).view(-1,1)
  if CUDA:
    x_offset=x_offset.cuda()
    y_offset=y_offset.cuda()
  x_y_offset=torch.cat((x_offset,y_offset),1).repeat(1,num_anchors).view(-1,2).unsqueeze(0)
  print(x_y_offset.size())
  prediction[:,:,:2]+=x_y_offset
  anchors=torch.FloatTensor(anchors)
  if CUDA:
    anchors=anchors.cuda()
  anchors=anchors.repeat((grid_size*grid_size),1).unsqueeze(0)
  prediction[:,:,2:4]=torch.exp(prediction[:,:,2:4])*anchors
  prediction[:,:,5:5+num_classes]=torch.sigmoid(prediction[:,:,5:5+num_classes])
  prediction[:,:,:4]*=stride
  return prediction